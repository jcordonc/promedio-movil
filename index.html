<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Promedio móvil + Control (Setpoint/Límites)</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; margin: 0; background:#f6f7fb; }
    header { padding: 18px 20px; background: white; border-bottom: 1px solid #e6e8ef; }
    h1 { margin: 0; font-size: 18px; }
    main { display: grid; grid-template-columns: 420px 1fr; gap: 14px; padding: 14px; }
    .card { background: white; border: 1px solid #e6e8ef; border-radius: 14px; padding: 14px; box-shadow: 0 1px 6px rgba(0,0,0,.04); }
    label { font-size: 12px; color:#40465a; display:block; margin-bottom: 6px; }
    input, textarea, select, button {
      width: 100%; box-sizing: border-box; border-radius: 10px;
      border: 1px solid #d8dcec; padding: 10px; font-size: 14px;
    }
    textarea { min-height: 120px; resize: vertical; }
    .row { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .row3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; }
    .btns { display:flex; gap:10px; margin-top:10px; }
    button { cursor:pointer; border: 1px solid #d8dcec; background:#111827; color:white; }
    button.secondary { background:white; color:#111827; }
    button.danger { background:#b42318; border-color:#b42318; }
    table { width:100%; border-collapse: collapse; margin-top:10px; }
    th, td { border-bottom: 1px solid #eef0f6; padding: 8px 6px; font-size: 13px; text-align:left; }
    th { color:#40465a; font-weight: 600; }
    .muted { color:#6b7280; font-size: 12px; }
    canvas { width: 100%; height: 460px; }
    .pill {
      display:inline-block; padding:4px 10px; border-radius:999px;
      font-size:12px; border:1px solid #e6e8ef; background:#fafbff; color:#40465a;
    }
    @media (max-width: 980px) { main { grid-template-columns: 1fr; } }
  </style>
</head>
<body>
<header>
  <h1>Promedio móvil + Gráfico de control (Setpoint/LCL/UCL)</h1>
  <div class="muted">Se guarda localmente en tu navegador (no se envía a ningún servidor).</div>
</header>

<main>
  <section class="card">
    <h2 style="margin:0 0 10px 0; font-size:15px;">Datos</h2>

    <div class="row">
      <div>
        <label for="dateInput">Fecha (opcional)</label>
        <input id="dateInput" type="date" />
        <div class="muted">Si no pones fecha, se usará índice 1..N.</div>
      </div>
      <div>
        <label for="valueInput">Valor</label>
        <input id="valueInput" type="number" step="any" placeholder="Ej. 12.5" />
      </div>
    </div>

    <div class="btns">
      <button id="addBtn">Agregar</button>
      <button class="secondary" id="clearBtn" title="Borra todo">Limpiar todo</button>
    </div>

    <hr style="border:none;border-top:1px solid #eef0f6;margin:14px 0;">

    <label for="bulkInput">Pegar lista (una por línea)</label>
    <textarea id="bulkInput" placeholder="Ejemplos:
2026-01-01, 12.5
2026/01/02 13.0
12.7"></textarea>

    <div class="btns">
      <button class="secondary" id="importBtn">Importar</button>
      <button class="secondary" id="exportBtn">Exportar CSV</button>
    </div>

    <hr style="border:none;border-top:1px solid #eef0f6;margin:14px 0;">

    <h2 style="margin:0 0 10px 0; font-size:15px;">Promedio móvil</h2>
    <label for="windowInput">Ventana (N)</label>
    <input id="windowInput" type="number" min="1" value="7" />
    <div class="muted">MA empieza a partir del punto N.</div>

    <hr style="border:none;border-top:1px solid #eef0f6;margin:14px 0;">

    <h2 style="margin:0 0 10px 0; font-size:15px;">Control: Setpoint y límites</h2>

    <label for="controlMode">Modo de límites</label>
    <select id="controlMode">
      <option value="tolerance">Setpoint ± tolerancia</option>
      <option value="direct">LCL/UCL directos</option>
    </select>

    <div class="row3" style="margin-top:10px;">
      <div>
        <label for="setpointInput">Setpoint (objetivo)</label>
        <input id="setpointInput" type="number" step="any" placeholder="Ej. 12.0" />
      </div>
      <div id="tolWrap">
        <label for="toleranceInput">Tolerancia (±)</label>
        <input id="toleranceInput" type="number" step="any" placeholder="Ej. 1.5" />
      </div>
      <div id="uclWrap" style="display:none;">
        <label for="uclInput">UCL</label>
        <input id="uclInput" type="number" step="any" placeholder="Ej. 13.5" />
      </div>
    </div>

    <div class="row3" style="margin-top:10px;">
      <div id="lclWrap" style="display:none;">
        <label for="lclInput">LCL</label>
        <input id="lclInput" type="number" step="any" placeholder="Ej. 10.5" />
      </div>
      <div>
        <label for="showControl">Mostrar líneas</label>
        <select id="showControl">
          <option value="on">Sí</option>
          <option value="off">No</option>
        </select>
      </div>
      <div>
        <label for="persistInfo">Guardado</label>
        <div class="pill" id="persistInfo">Activo</div>
      </div>
    </div>

    <div class="btns">
      <button class="secondary" id="saveSettingsBtn">Guardar ajustes</button>
      <button class="danger" id="deleteLastBtn">Eliminar último</button>
    </div>

    <h3 style="margin:14px 0 8px 0; font-size:14px;">Tabla</h3>
    <div style="max-height:240px; overflow:auto; border:1px solid #eef0f6; border-radius:10px;">
      <table>
        <thead>
          <tr><th>#</th><th>Fecha</th><th>Valor</th><th>MA</th></tr>
        </thead>
        <tbody id="tableBody"></tbody>
      </table>
    </div>

    <div class="muted" style="margin-top:10px;">
      Tip: si quieres “control chart” clásico (X̄/R, X̄/S, I-MR, etc.), dímelo y lo adapto.
    </div>
  </section>

  <section class="card">
    <h2 style="margin:0 0 10px 0; font-size:15px;">Gráfica</h2>
    <canvas id="chart" width="1200" height="600"></canvas>
    <div class="muted" id="summary" style="margin-top:10px;"></div>
  </section>
</main>

<script>
  // ===== Persistencia =====
  const STORAGE_KEY = "pm_control_state_v1";

  const state = {
    points: [], // { xLabel, x, value, date }
    settings: {
      windowSize: 7,
      controlMode: "tolerance", // "tolerance" | "direct"
      setpoint: null,
      tolerance: null,
      lcl: null,
      ucl: null,
      showControl: "on"
    }
  };

  function saveToStorage() {
    try {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
      els.persistInfo.textContent = "Guardado";
    } catch (e) {
      els.persistInfo.textContent = "No se pudo guardar";
      console.warn(e);
    }
  }

  function loadFromStorage() {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return false;
      const parsed = JSON.parse(raw);

      // Validación básica
      if (parsed && Array.isArray(parsed.points) && parsed.settings) {
        state.points = parsed.points.map((p, i) => ({
          xLabel: String(p.xLabel ?? (i+1)),
          x: Number(p.x ?? (i+1)),
          value: Number(p.value),
          date: String(p.date ?? "")
        })).filter(p => Number.isFinite(p.value));

        state.settings = { ...state.settings, ...parsed.settings };
        return true;
      }
    } catch (e) {
      console.warn("Error leyendo storage:", e);
    }
    return false;
  }

  // ===== Helpers =====
  function safeNumber(v) {
    const n = Number(v);
    return Number.isFinite(n) ? n : null;
  }

  function addPoint(dateStr, value) {
    const idx = state.points.length + 1;
    const xLabel = dateStr ? dateStr : String(idx);
    state.points.push({ xLabel, x: idx, value, date: dateStr || "" });
    saveToStorage();
    render();
  }

  function movingAverage(values, windowSize) {
    const ma = new Array(values.length).fill(null);
    if (windowSize <= 0) return ma;
    let sum = 0;
    for (let i = 0; i < values.length; i++) {
      sum += values[i];
      if (i >= windowSize) sum -= values[i - windowSize];
      if (i >= windowSize - 1) ma[i] = sum / windowSize;
    }
    return ma;
  }

  function parseBulk(text) {
    const lines = text.split("\n").map(l => l.trim()).filter(Boolean);
    const parsed = [];
    for (const line of lines) {
      const parts = line.split(/[,;|\t]+/).map(s => s.trim()).filter(Boolean);

      let dateCandidate = "";
      let valueCandidate = null;

      if (parts.length >= 2) {
        const n0 = safeNumber(parts[0]);
        const n1 = safeNumber(parts[1]);
        if (n0 !== null && n1 === null) { valueCandidate = n0; dateCandidate = parts[1]; }
        else if (n1 !== null && n0 === null) { valueCandidate = n1; dateCandidate = parts[0]; }
        else if (n0 !== null && n1 !== null) { valueCandidate = n1; dateCandidate = parts[0]; }
        else {
          const m = line.match(/-?\d+(\.\d+)?/);
          valueCandidate = m ? safeNumber(m[0]) : null;
        }
      } else {
        const n = safeNumber(parts[0]);
        if (n !== null) valueCandidate = n;
        else {
          const m = line.match(/(-?\d+(\.\d+)?)/);
          valueCandidate = m ? safeNumber(m[0]) : null;
          dateCandidate = line.replace(m ? m[0] : "", "").trim();
        }
      }

      if (valueCandidate === null) continue;

      if (dateCandidate) {
        const norm = dateCandidate.replaceAll("/", "-");
        if (/^\d{4}-\d{2}-\d{2}$/.test(norm)) dateCandidate = norm;
      }

      parsed.push({ date: dateCandidate || "", value: valueCandidate });
    }
    return parsed;
  }

  function exportCSV() {
    const windowSize = Math.max(1, parseInt(els.windowInput.value || "1", 10));
    const values = state.points.map(p => p.value);
    const ma = movingAverage(values, windowSize);

    const limits = computeLimits();
    const rows = [["index","date","label","value","moving_avg","setpoint","lcl","ucl"]];
    for (let i = 0; i < state.points.length; i++) {
      const p = state.points[i];
      rows.push([
        String(i + 1),
        p.date || "",
        p.xLabel,
        String(p.value),
        ma[i] === null ? "" : String(ma[i]),
        limits.setpoint ?? "",
        limits.lcl ?? "",
        limits.ucl ?? ""
      ]);
    }

    const csv = rows.map(r => r.map(cell => {
      const s = String(cell ?? "");
      return /[",\n]/.test(s) ? `"${s.replaceAll('"','""')}"` : s;
    }).join(",")).join("\n");

    const blob = new Blob([csv], { type: "text/csv;charset=utf-8" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "promedio_movil_control.csv";
    a.click();
    URL.revokeObjectURL(url);
  }

  function computeLimits() {
    const mode = state.settings.controlMode;
    const show = state.settings.showControl === "on";
    if (!show) return { setpoint: null, lcl: null, ucl: null };

    const sp = safeNumber(state.settings.setpoint);
    if (sp === null) return { setpoint: null, lcl: null, ucl: null };

    if (mode === "tolerance") {
      const tol = safeNumber(state.settings.tolerance);
      if (tol === null) return { setpoint: sp, lcl: null, ucl: null };
      return { setpoint: sp, lcl: sp - tol, ucl: sp + tol };
    }

    // direct
    const lcl = safeNumber(state.settings.lcl);
    const ucl = safeNumber(state.settings.ucl);
    return { setpoint: sp, lcl: lcl, ucl: ucl };
  }

  // ===== UI elements =====
  const els = {
    dateInput: document.getElementById("dateInput"),
    valueInput: document.getElementById("valueInput"),
    addBtn: document.getElementById("addBtn"),
    clearBtn: document.getElementById("clearBtn"),
    bulkInput: document.getElementById("bulkInput"),
    importBtn: document.getElementById("importBtn"),
    exportBtn: document.getElementById("exportBtn"),
    windowInput: document.getElementById("windowInput"),
    tableBody: document.getElementById("tableBody"),
    deleteLastBtn: document.getElementById("deleteLastBtn"),
    canvas: document.getElementById("chart"),
    summary: document.getElementById("summary"),
    controlMode: document.getElementById("controlMode"),
    setpointInput: document.getElementById("setpointInput"),
    toleranceInput: document.getElementById("toleranceInput"),
    lclInput: document.getElementById("lclInput"),
    uclInput: document.getElementById("uclInput"),
    showControl: document.getElementById("showControl"),
    saveSettingsBtn: document.getElementById("saveSettingsBtn"),
    persistInfo: document.getElementById("persistInfo"),
    tolWrap: document.getElementById("tolWrap"),
    lclWrap: document.getElementById("lclWrap"),
    uclWrap: document.getElementById("uclWrap"),
  };

  function syncSettingsToInputs() {
    els.windowInput.value = String(state.settings.windowSize ?? 7);
    els.controlMode.value = state.settings.controlMode ?? "tolerance";
    els.setpointInput.value = state.settings.setpoint ?? "";
    els.toleranceInput.value = state.settings.tolerance ?? "";
    els.lclInput.value = state.settings.lcl ?? "";
    els.uclInput.value = state.settings.ucl ?? "";
    els.showControl.value = state.settings.showControl ?? "on";
    updateControlModeVisibility();
  }

  function readInputsToSettings() {
    state.settings.windowSize = Math.max(1, parseInt(els.windowInput.value || "1", 10));
    state.settings.controlMode = els.controlMode.value;
    state.settings.setpoint = safeNumber(els.setpointInput.value);
    state.settings.tolerance = safeNumber(els.toleranceInput.value);
    state.settings.lcl = safeNumber(els.lclInput.value);
    state.settings.ucl = safeNumber(els.uclInput.value);
    state.settings.showControl = els.showControl.value;
  }

  function updateControlModeVisibility() {
    const mode = els.controlMode.value;
    if (mode === "tolerance") {
      els.tolWrap.style.display = "block";
      els.lclWrap.style.display = "none";
      els.uclWrap.style.display = "none";
    } else {
      els.tolWrap.style.display = "none";
      els.lclWrap.style.display = "block";
      els.uclWrap.style.display = "block";
    }
  }

  // ===== Render =====
  function renderTable(values, ma) {
    els.tableBody.innerHTML = "";
    for (let i = 0; i < state.points.length; i++) {
      const p = state.points[i];
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>${i + 1}</td>
        <td>${p.date || ""}</td>
        <td>${p.value}</td>
        <td>${ma[i] === null ? "" : ma[i].toFixed(4)}</td>
      `;
      els.tableBody.appendChild(tr);
    }
  }

  function drawHorizontalLine(ctx, cssW, padding, yPos, label, dash = [6,4]) {
    ctx.save();
    ctx.setLineDash(dash);
    ctx.beginPath();
    ctx.moveTo(padding.left, yPos);
    ctx.lineTo(cssW - padding.right, yPos);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillText(label, padding.left + 6, yPos - 6);
    ctx.restore();
  }

  function drawChart(labels, values, maValues) {
    const canvas = els.canvas;
    const ctx = canvas.getContext("2d");

    // HiDPI
    const dpr = window.devicePixelRatio || 1;
    const cssW = canvas.clientWidth || 1200;
    const cssH = 460;
    canvas.style.height = cssH + "px";
    canvas.width = Math.floor(cssW * dpr);
    canvas.height = Math.floor(cssH * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    ctx.clearRect(0, 0, cssW, cssH);

    const padding = { left: 60, right: 20, top: 22, bottom: 55 };
    const w = cssW - padding.left - padding.right;
    const h = cssH - padding.top - padding.bottom;

    const limits = computeLimits();
    const extraY = [];
    if (limits.setpoint !== null) extraY.push(limits.setpoint);
    if (limits.lcl !== null) extraY.push(limits.lcl);
    if (limits.ucl !== null) extraY.push(limits.ucl);

    const allY = values
      .concat(maValues.filter(v => v !== null))
      .concat(extraY);

    const minY = Math.min(...allY);
    const maxY = Math.max(...allY);
    const span = (maxY - minY) || 1;

    const x = (i) => padding.left + (labels.length === 1 ? w/2 : (i / (labels.length - 1)) * w);
    const y = (v) => padding.top + (1 - ((v - minY) / span)) * h;

    // axes
    ctx.strokeStyle = "#cfd6ea";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(padding.left, padding.top);
    ctx.lineTo(padding.left, padding.top + h);
    ctx.lineTo(padding.left + w, padding.top + h);
    ctx.stroke();

    // grid
    ctx.strokeStyle = "#eef0f6";
    for (let i = 1; i <= 4; i++) {
      const yy = padding.top + (i/5) * h;
      ctx.beginPath();
      ctx.moveTo(padding.left, yy);
      ctx.lineTo(padding.left + w, yy);
      ctx.stroke();
    }

    // labels
    ctx.fillStyle = "#40465a";
    ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Arial";

    const tickCount = Math.min(7, labels.length);
    for (let t = 0; t < tickCount; t++) {
      const i = tickCount === 1 ? 0 : Math.round((t/(tickCount-1)) * (labels.length - 1));
      const lx = x(i);
      ctx.fillText(labels[i], Math.max(0, lx - 20), padding.top + h + 28);
    }

    ctx.fillText(minY.toFixed(2), 6, padding.top + h);
    ctx.fillText(maxY.toFixed(2), 6, padding.top + 12);

    function drawLine(series, stroke, width = 2, dashed = false) {
      ctx.strokeStyle = stroke;
      ctx.lineWidth = width;
      ctx.setLineDash(dashed ? [6,4] : []);
      ctx.beginPath();
      let started = false;
      for (let i = 0; i < series.length; i++) {
        const v = series[i];
        if (v === null || !Number.isFinite(v)) continue;
        const xx = x(i);
        const yy = y(v);
        if (!started) { ctx.moveTo(xx, yy); started = true; }
        else ctx.lineTo(xx, yy);
      }
      ctx.stroke();
      ctx.setLineDash([]);
    }

    // series
    drawLine(values, "#111827", 2, false);     // dato
    drawLine(maValues, "#2563eb", 3, true);    // MA

    // control lines
    ctx.strokeStyle = "#7c3aed";
    ctx.fillStyle = "#7c3aed";
    if (limits.setpoint !== null) drawHorizontalLine(ctx, cssW, padding, y(limits.setpoint), `Setpoint: ${limits.setpoint}`, [2,0]);
    ctx.strokeStyle = "#b42318";
    ctx.fillStyle = "#b42318";
    if (limits.ucl !== null) drawHorizontalLine(ctx, cssW, padding, y(limits.ucl), `UCL: ${limits.ucl}`, [8,4]);
    if (limits.lcl !== null) drawHorizontalLine(ctx, cssW, padding, y(limits.lcl), `LCL: ${limits.lcl}`, [8,4]);

    // legend
    ctx.fillStyle = "#111827";
    ctx.fillText("Dato", padding.left + 10, padding.top + 14);
    ctx.fillStyle = "#2563eb";
    ctx.fillText("Promedio móvil", padding.left + 60, padding.top + 14);
  }

  function render() {
    const windowSize = Math.max(1, parseInt(els.windowInput.value || "1", 10));
    state.settings.windowSize = windowSize;

    const values = state.points.map(p => p.value);
    const labels = state.points.map(p => p.xLabel);
    const ma = movingAverage(values, windowSize);

    renderTable(values, ma);
    if (values.length > 0) drawChart(labels, values, ma);

    const lastMA = [...ma].reverse().find(v => v !== null);
    const limits = computeLimits();

    els.summary.textContent =
      `Puntos: ${values.length} | Ventana MA: ${windowSize} | Último MA: ${
        lastMA === undefined ? "N/A" : lastMA.toFixed(4)
      } | Setpoint: ${limits.setpoint ?? "—"} | LCL: ${limits.lcl ?? "—"} | UCL: ${limits.ucl ?? "—"}`;

    saveToStorage();
  }

  // ===== Eventos =====
  els.addBtn.addEventListener("click", () => {
    const value = safeNumber(els.valueInput.value);
    if (value === null) return alert("Ingresa un valor numérico válido.");
    const dateStr = els.dateInput.value || "";
    addPoint(dateStr, value);
    els.valueInput.value = "";
  });

  els.clearBtn.addEventListener("click", () => {
    if (!confirm("¿Borrar TODOS los datos guardados en este navegador?")) return;
    state.points = [];
    saveToStorage();
    render();
  });

  els.importBtn.addEventListener("click", () => {
    const parsed = parseBulk(els.bulkInput.value || "");
    if (parsed.length === 0) return alert("No se detectaron valores válidos.");
    for (const p of parsed) addPoint(p.date, p.value);
    els.bulkInput.value = "";
  });

  els.exportBtn.addEventListener("click", exportCSV);

  els.windowInput.addEventListener("input", () => {
    readInputsToSettings();
    render();
  });

  els.deleteLastBtn.addEventListener("click", () => {
    state.points.pop();
    saveToStorage();
    render();
  });

  els.controlMode.addEventListener("change", () => {
    updateControlModeVisibility();
  });

  els.saveSettingsBtn.addEventListener("click", () => {
    readInputsToSettings();

    // Validaciones suaves
    if (state.settings.showControl === "on" && safeNumber(state.settings.setpoint) === null) {
      alert("Para mostrar control, ingresa un Setpoint válido (número).");
      return;
    }
    if (state.settings.controlMode === "tolerance" && state.settings.showControl === "on") {
      if (safeNumber(state.settings.tolerance) === null) {
        alert("En modo tolerancia, ingresa una tolerancia válida (número).");
        return;
      }
    }

    saveToStorage();
    render();
  });

  // Re-render en resize para que el canvas se ajuste
  window.addEventListener("resize", () => render());

  // ===== Inicio =====
  const loaded = loadFromStorage();
  syncSettingsToInputs();

  // Si no hay datos guardados, deja unos de ejemplo (solo la primera vez)
  if (!loaded || state.points.length === 0) {
    addPoint("2026-01-01", 10);
    addPoint("2026-01-02", 12);
    addPoint("2026-01-03", 9);
    addPoint("2026-01-04", 14);
    addPoint("2026-01-05", 13);
    addPoint("2026-01-06", 15);
    state.settings.setpoint = 12;
    state.settings.tolerance = 2;
    syncSettingsToInputs();
    saveToStorage();
  }

  render();
</script>
</body>
</html>
